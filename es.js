/*! (c) Andrea Giammarchi */
let t=null;const e=e=>{let s=t;s||(t=new Set);try{e()}finally{if(!s){[t,s]=[null,t];for(const t of s)t._()}}},s=t=>{const e=[...t];return t.clear(),e};class n extends Set{constructor(t){super()._=t}dispose(){for(const t of s(this))t.delete(this),t.dispose?.()}}let r=null;const o=t=>{const e=new n((()=>{const s=r;r=e;try{t()}finally{r=s}}));return e},l=(t,e)=>{const s=o((()=>{e=t(e)}));return r&&r.add(s),s._(),()=>s.dispose()},u=t=>{const e=r;r=null,t(),r=e};class i extends Set{constructor(t){super()._=t}get value(){return r&&r.add(this.add(r)),this._}set value(e){if(this._!==e){this._=e;const n=!t;for(const e of s(this))n?e._():t.add(e)}}peek(){return this._}toJSON(){return this.value}valueOf(){return this.value}toString(){return String(this.value)}}const c=t=>new i(t);class a extends i{constructor(t,e){super(e).f=t,this.e=null}get value(){return this.e||(this.e=o((()=>{super.value=this.f(this._)})))._(),super.value}set value(t){throw new Error("computed is read-only")}}const d=(t,e)=>new a(t,e);export{a as Computed,i as Signal,e as batch,d as computed,l as effect,c as signal,u as untracked};
