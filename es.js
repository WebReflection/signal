/*! (c) Andrea Giammarchi */
let t=null;const e=e=>{let s=t;s||(t=new Set);try{e()}finally{if(!s){[t,s]=[null,t];for(const t of s)t._()}}},s=t=>{const e=[...t];return t.clear(),e};class r extends Set{constructor(t){super()._=t}dispose(){for(const t of s(this))t.delete(this),t.dispose?.()}}let n=null;const o=(t,e)=>{const s=new r((()=>{const r=n;n=s;try{e=t(e)}finally{n=r}}));return n&&n.add(s),s._(),()=>s.dispose()};class u extends Set{constructor(t){super()._=t}get value(){return n&&n.add(this.add(n)),this._}set value(e){if(this._!==e){this._=e;const r=!t;for(const e of s(this))r?e._():t.add(e)}}peek(){return this._}then(t){t(this.value)}toJSON(){return this.value}valueOf(){return this.value}toString(){return String(this.value)}}const l=t=>new u(t);class i extends u{constructor(t,e){super(e).dispose=o((()=>{super.value=t(this._)}))}get value(){return super.value}set value(t){throw new Error("computed is read-only")}}const a=(t,e)=>new i(t,e);export{i as Computed,u as Signal,e as batch,a as computed,o as effect,l as signal};
