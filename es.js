class e{#e;#t=[];constructor(e){this.#e=e}get value(){const{length:e}=l;return e&&this.#t.push(l[e-1]),this.#e}set value(e){this.#e!==e&&(this.#e=e,this.#t.length&&(a===l?o(this.#t.splice(0)):a.push(...this.#t.splice(0))))}peek(){return this.#e}then(e){e(this.value)}toJSON(){return this.value}valueOf(){return this.value}toString(){return String(this.value)}}class t extends e{constructor(e,t){super(t).dispose=r((()=>{super.value=e(this.peek())}))}get value(){return super.value}set value(e){throw new Error("computed is read-only")}}const s=e=>{const t=a===l;t&&(a=[]);try{e()}finally{if(t){const e=a;a=l,o(e)}}},u=(e,s)=>new t(e,s),r=(e,t)=>{let s=!0;const u=()=>{if(s){l.push(u);try{t=e(t)}finally{l.pop()}}},r=()=>{s=!1;for(const e of i.get(u))e()};i.set(u,[]);const{length:n}=l;return n&&i.get(l[n-1]).push(r),u(),r},n=t=>new e(t),l=[],i=new WeakMap,o=e=>{for(const t of new Set(e))t()};let a=l;export{t as Computed,e as Signal,s as batch,u as computed,r as effect,n as signal};
