/*! (c) Andrea Giammarchi */
const e=[],t=new WeakSet,s=new WeakMap,n=(e,s)=>{for(const n of e)t.has(n)?e.delete(n):s&&n()};let r=e;const u=t=>{const s=r===e;s&&(r=[]);try{t()}finally{if(s){const t=new Set(r);r=e,n(t,!0)}}},a=Symbol(),l=e=>new o(e);class o{constructor(e){this._value=e,this._effects=new Set}get value(){const{length:t}=e;return t&&this._effects.add(e[t-1]),this._value}set value(t){t===a?n(this._effects,!1):this._value!==t&&(this._value=t,r===e?n(this._effects,!0):r.push(...this._effects))}peek(){return this._value}then(){return this.value}toJSON(){return this.value}valueOf(){return this.value}toString(){return String(this.value)}}const c=(e,t)=>new h(e,t);class h extends o{constructor(e,t){super(t).dispose=i((()=>{super.value=e(this._value)}))}get value(){return super.value}set value(e){throw new Error("computed.value is read-only")}}const i=(n,r)=>{const u=()=>{r=n(r)},a=()=>{t.add(u);for(const e of s.get(u))e()};s.set(u,[]);const l=e.push(u)-1;l&&s.get(e[l-1]).push(a);try{return u(),a}finally{e.pop()}};export{h as Computed,o as Signal,u as batch,c as computed,a as drain,i as effect,l as signal};
