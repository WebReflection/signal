class e{#e;#t=[];constructor(e){this.#e=e}get value(){return this.#t.push(l.at(-1)),this.#e}set value(e){this.#e!==e&&(this.#e=e,o===l?i(this.#t.splice(0)):o.push(...this.#t.splice(0)))}peek(){return this.#e}then(){return this.value}toJSON(){return this.value}valueOf(){return this.value}toString(){return String(this.value)}}class t extends e{constructor(e,t){super(t).dispose=r((()=>{super.value=e(this.peek())}))}get value(){return super.value}set value(e){throw new Error("computed is read-only")}}const s=e=>{const t=o===l;t&&(o=[]);try{e()}finally{if(t){const e=o;o=l,i(e)}}},u=(e,s)=>new t(e,s),r=(e,t)=>{let s=!0;const u=()=>{if(s){l.push(u);try{t=e(t)}finally{l.pop()}}},r=()=>{s=!1;for(const e of a.get(u))e()};return a.set(u,[]),a.get(l.at(-1)).push(r),u(),r},n=t=>new e(t),l=[()=>{}],a=new WeakMap([[l[0],Object.assign([],{push(){}})]]),i=e=>{for(const t of new Set(e))t()};let o=l;export{t as Computed,e as Signal,s as batch,u as computed,r as effect,n as signal};
