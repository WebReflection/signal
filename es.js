class e{#e;#t=[];constructor(e){this.#e=e}get value(){const{length:e}=l;return e&&this.#t.push(l[e-1]),this.#e}set value(e){this.#e!==e&&(this.#e=e,this.#t.length&&(a===l?o(this.#t.splice(0)):a.push(...this.#t.splice(0))))}peek(){return this.#e}then(){return this.value}toJSON(){return this.value}valueOf(){return this.value}toString(){return String(this.value)}}class t extends e{constructor(e,t){super(t).dispose=u((()=>{super.value=e(this.peek())}))}get value(){return super.value}set value(e){throw new Error("computed is read-only")}}const s=e=>{const t=a===l;t&&(a=[]);try{e()}finally{if(t){const e=a;a=l,o(e)}}},r=(e,s)=>new t(e,s),u=(e,t)=>{let s=!0;const r=()=>{if(s){l.push(r);try{t=e(t)}finally{l.pop()}}},u=()=>{s=!1;for(const e of i.get(r))e()};i.set(r,[]);const{length:n}=l;return n&&i.get(l[n-1]).push(u),r(),u},n=t=>new e(t),l=[],i=new WeakMap,o=e=>{for(const t of new Set(e))t()};let a=l;export{t as Computed,e as Signal,s as batch,r as computed,u as effect,n as signal};
